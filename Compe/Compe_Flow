## 2部マッチング

    int V=0;//頂点数
    vector<int>G[10000];//隣接リスト
    int match[10000];//マッチングのペア
    bool used[10000];

    void add_edge(int u, int v){
      G[u].push_back(v);
      G[v].push_back(u);
    }
    bool dfs(int v){
      used[v]=true;
      for(int i=0;i<G[v].size();i++){
        int u=G[v][i], w=match[u];
        if(w<0 || (!used[w] && dfs(w))){
          match[v]=u;
          match[u]=v;
          return true;
        }
      }
      return false;
    }
    int biparticle_matching(int vv){//頂点数を引数で渡す
      V=vv;
      int res=0;
      memset(match, -1, sizeof(match));
      for(int v=0;v<V;v++){
        if(match[v]<0){
          memset(used,false,sizeof(used));
          if(dfs(v)){
            res++;
          }
        }
      }
    return res;
    }


## 最大費用流

    struct edge {int to,cap,rev;};
    vector<edge> G[MAX_V];
    int level[MAX_V];
    int iter[MAX_V];

    void add_edge(int from, int to, int cap){
      G[from].push_back((edge){to,cap,G[to].size()});
      G[to].push_back((edge){from,0,G[from].size()-1});
    }

    void bfs(int s){
      memset(level, -1, sizeof(level));
      queue<int> que;
      level[s]=0;
      que.push(s);
      while(!que.empty()){
        int v=que.fromt();
        que.pop();
        for(int i=0;i<G[v].size();i++){
          edge &e=G[v][i];
          if(e.cap>0 && level[e.to]<0){
            level[e.to]=level[v]+1;
            que.push(e.to);
          }
        }
      }
    }

    void dfs(int v, int t, int f){
      if(v==t)return f;
      for(int &i=iter[v];i<G[v].size();i++){
        edge &e=G[v][i];
        if(e.cap>0 && level[v]<level[e.to]){
          if(d>0){
            e.cap-=d;
            G[e.to][e.rev].cap+=d;
            return d;
          }
        }
      }
      return 0;
    }
    //使い方
    while(1){
      bfs(s);//s:スタート
      if(level[t]<0) return flow;
      memset(iter,0,sizeof(iter));
      int f;
      while(f=dfs(s,t,INF)>0){
        flow+=f;
      }
    }
