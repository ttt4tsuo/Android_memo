## Math

素数判定

    int isPrim(int a){
      if(a==1) return 0;
      for(int i=2;i*i<=a;i++){
        if(a%i==0){
          return 0;
        }
      }
      return 1;
    }

素因数分解

    int A;
    scanf("%d",&A);
    map<int,int> ans;
    ans.clear();

    int j=2;
    while(A>1){
      if(A%j==0){
        if(ans.find(j)==ans.end()){
            ans.insert(map<int,int>::value_type(j,1));
        }else{
            ans[j]++;
        }
        A=A/j;
      }else{
        j++;
      }
    }

    map<int,int>::iterator it=ans.begin();
    while(it!=ans.end()){
      printf("%d %d\n",it->first,it->second);
      it++;
    }

エラトステネスの櫛

    int prime[100001];
    bool is_prime[100000+2];

    int p=0;
    for(int i=0;i<=100001;i++){
      is_prime[i]=true;
      }
    is_prime[0]=false;
    is_prime[1]=false;
    for(int i=2;i<=100001;i++){
      if(is_prime[i]){
        prime[p++]=i;
        for(int j=2*i;j<=100001;j+=i){
          is_prime[j]=false;
        }
      }
    }

最大公約数

    //#include <numeric>にgcd()あり
    int gcd(int a, int b){
      if(a<b){
        swap(a,b);
      }
      while(b){
        int m = a % b;
        a = b;
        b = m;
      }
      return a;
    }

最小公倍数

    //#include <numeric>にlcm()あり
    int lcm(int a, int b){
      return (a*b)/gcd(a,b);
    }

## 繰り返し2乗法

    long long mod_pow(long long x, long long n, long long mod){
      //xのn乗を計算するのにn乗を2進表記にして計算
      //x^22 = x^16 + x^4 + x^2
      long long ret=1;
      while(n>0){
        if(n&1){
          ret=(ret*x)%mod;//答えに付加
        }
        x=(x*x)%mod;//2乗
        n >>=1;
        }
        return ret;
    }
